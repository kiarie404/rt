There are multiple ways to mix Rust and assembly... each with it's own caveats.  
1. inline
2. multiline
3. File-wise

Support for inline assembly is provided via the asm! and global_asm! macros. It can be used to embed handwritten assembly in the assembly output generated by the compiler.  



Example inline: 

```rust 
#![feature(asm)]

use std::arch::asm; 


fn riscv_add(a: i32, b: i32) -> i32 {
    let result;
    unsafe {
        asm!(
            "add {result}, {a}, {b}",
            result = out(reg) result,
            a = in(reg) a,
            b = in(reg) b,
        );
    }
    result
}

fn main() {
    println!("10 + 20 = {}", riscv_add(10, 20));
}
```


unsafe: compiler does not know what magic you did within the `asm!` block.  

**Disadvanntages:**
1. A lot of work : Writing unsafe blocks
2. Unsafe blocks everywhere


**Alternatives**  
For stable Rust, consider using:
- The riscv crate for CSR access
- The riscv-rt crate for startup code
- External assembly files for larger blocks